# 2.5 网络模块设计说明

## 一、使用的网络协议

本系统使用 **HTTP 协议**（基于 TCP）进行网络通信，具体采用 **HTTP GET 请求**方式调用在线翻译 API 服务。

**技术实现：**
- 使用 Qt Network 模块的 `QNetworkAccessManager` 类管理网络请求
- 使用 `QNetworkRequest` 封装 HTTP 请求信息（URL、请求头等）
- 使用 `QNetworkReply` 处理服务器返回的响应数据
- API 接口：`https://api.mymemory.translated.net/get`（MyMemory Translation API）

**代码示例：**
```cpp
QNetworkAccessManager *m_networkManager = new QNetworkAccessManager(this);
QUrl url("https://api.mymemory.translated.net/get");
QUrlQuery query;
query.addQueryItem("q", text);  // 待翻译文本
query.addQueryItem("langpair", fromLang + "|" + toLang);  // 语言方向
url.setQuery(query);
QNetworkRequest request(url);
m_networkManager->get(request);  // 发送 HTTP GET 请求
```

**协议选择原因：** HTTP 协议是 Web API 的标准协议，具有简单易用、跨平台、支持 JSON 数据格式等优势，非常适合翻译 API 这类 RESTful 服务调用场景。

---

## 二、请求流程说明

### 翻译请求完整流程：

1. **用户触发翻译**：用户在输入框输入文本，点击"翻译"按钮或按回车键
2. **输入验证**：检查输入文本是否为空，如为空则提示用户
3. **缓存查询**：优先查询本地 SQLite 数据库缓存，如果存在相同查询则直接返回缓存结果
4. **构建网络请求**：如果缓存未命中，构建 HTTP GET 请求 URL，包含待翻译文本和语言方向参数
5. **发送异步请求**：通过 `QNetworkAccessManager::get()` 发送异步 HTTP 请求，同时禁用翻译按钮防止重复请求
6. **等待响应**：网络请求在后台异步执行，UI 线程不被阻塞，用户可以继续操作其他功能
7. **接收响应**：网络请求完成后，触发 `finished` 信号，调用 `handleTranslationFinished()` 槽函数
8. **解析数据**：使用 `QJsonDocument` 解析返回的 JSON 数据，提取翻译结果和多个释义
9. **更新 UI**：将解析后的翻译结果和例句显示到界面上，并保存到数据库缓存
10. **恢复状态**：重新启用翻译按钮，清除状态栏提示信息

### 流程图（PlantUML 代码）：



## 三、数据接收后如何更新 UI

### 更新机制：

网络请求完成后，通过 **Qt 信号槽机制**实现数据接收后的 UI 更新：

1. **信号触发**：`QNetworkAccessManager` 的 `finished(QNetworkReply *reply)` 信号在网络请求完成时自动触发

2. **槽函数处理**：`handleTranslationFinished(QNetworkReply *reply)` 槽函数接收响应数据并进行处理

3. **UI 更新步骤**：
   - **错误处理**：检查 `reply->error()`，如有错误则通过 `QMessageBox` 显示错误提示
   - **数据解析**：读取 `reply->readAll()` 获取响应数据，使用 `QJsonDocument` 解析 JSON
   - **提取数据**：从 JSON 对象中提取 `responseData.translatedText` 和 `matches` 数组中的多个释义
   - **格式化显示**：将多个释义格式化为编号列表，存储到 `QString` 变量中
   - **更新控件**：调用 `ui->textEditResult->setPlainText()` 和 `ui->textEditExamples->setPlainText()` 更新界面显示
   - **保存缓存**：调用 `saveHistory()` 将结果保存到数据库，触发 Model 的 `select()` 方法刷新历史记录视图
   - **恢复状态**：重新启用翻译按钮（`ui->btnTranslate->setEnabled(true)`），清除状态栏提示

**代码示例：**
```cpp
void MainWindow::handleTranslationFinished(QNetworkReply *reply)
{
    ui->btnTranslate->setEnabled(true);  // 恢复按钮状态
    
    // 解析JSON数据
    const QByteArray data = reply->readAll();
    QJsonDocument doc = QJsonDocument::fromJson(data);
    QJsonObject root = doc.object();
    
    // 提取翻译结果
    QString translated = root["responseData"].toObject()["translatedText"].toString();
    
    // 更新UI
    ui->textEditResult->setPlainText(translated);
    
    // 保存到数据库并刷新视图
    saveHistory(sourceText, translated, fromLang, toLang, exampleText);
}
```

---

## 四、异常与超时处理策略

### 1. **网络错误处理**

系统通过检查 `QNetworkReply::error()` 来捕获网络错误：

```cpp
if (reply->error() != QNetworkReply::NoError) {
    QMessageBox::warning(this, tr("网络错误"),
                         tr("请求失败：%1").arg(reply->errorString()));
    return;
}
```

**常见错误类型：**
- `NetworkAccessDeniedError`：网络访问被拒绝（如防火墙阻止）
- `HostNotFoundError`：无法找到服务器主机
- `TimeoutError`：请求超时
- `ConnectionRefusedError`：连接被拒绝

**处理策略：** 通过 `QMessageBox` 向用户显示友好的错误提示信息，包含具体的错误原因（`errorString()`），让用户了解问题所在。

### 2. **JSON 解析错误处理**

如果服务器返回的数据格式不正确或无法解析，系统会捕获 `QJsonParseError`：

```cpp
QJsonParseError parseError;
QJsonDocument doc = QJsonDocument::fromJson(data, &parseError);
if (parseError.error != QJsonParseError::NoError || !doc.isObject()) {
    QMessageBox::warning(this, tr("解析错误"),
                         tr("无法解析服务器返回的数据。"));
    return;
}
```

**处理策略：** 显示解析错误提示，确保程序不会因数据格式异常而崩溃。

### 3. **空数据检查**

在提取翻译结果时，系统会检查数据是否为空：

```cpp
if (translated.isEmpty()) {
    QMessageBox::information(this, tr("提示"), tr("未获取到翻译结果。"));
    return;
}
```

**处理策略：** 当 API 返回空结果时，给用户明确的提示，避免显示空白内容。

### 4. **超时处理**

虽然当前代码中未显式设置超时时间，但 `QNetworkAccessManager` 默认使用系统超时设置（通常为 30 秒）。可以通过以下方式设置自定义超时：

```cpp
QNetworkRequest request(url);
request.setTransferTimeout(10000);  // 设置10秒超时
```

**建议改进：** 可以添加超时处理逻辑，在请求超时时给用户明确提示，并允许重新尝试请求。

### 5. **资源管理**

使用 `QScopedPointer` 确保网络响应对象在使用完成后自动释放：

```cpp
QScopedPointer<QNetworkReply, QScopedPointerDeleteLater> guard(reply);
```

**处理策略：** 避免内存泄漏，确保资源正确释放。

---

## 五、如何避免阻塞 UI（异步请求机制）

### 1. **异步网络请求**

本系统使用 `QNetworkAccessManager::get()` 方法发送**异步 HTTP 请求**，这是 Qt 网络模块的核心特性：

**工作原理：**
- `QNetworkAccessManager` 内部使用 Qt 的事件循环机制，将网络 I/O 操作放在后台线程执行
- 主线程（UI 线程）不会被阻塞，用户可以继续操作界面
- 网络请求完成后，通过信号槽机制通知主线程处理结果

**代码实现：**
```cpp
// 初始化网络管理器（在构造函数中）
m_networkManager = new QNetworkAccessManager(this);

// 连接信号槽
connect(m_networkManager, &QNetworkAccessManager::finished,
        this, &MainWindow::handleTranslationFinished);

// 发送异步请求（不会阻塞）
m_networkManager->get(request);  // 立即返回，不等待响应
```

### 2. **UI 状态管理**

在发送网络请求时，通过禁用按钮和显示状态提示，让用户知道系统正在处理：

```cpp
// 发送请求前
ui->btnTranslate->setEnabled(false);  // 禁用按钮，防止重复请求
statusBar()->showMessage(tr("正在查询中，请稍候..."));  // 状态提示

// 请求完成后
ui->btnTranslate->setEnabled(true);   // 恢复按钮
statusBar()->clearMessage();          // 清除提示
```

### 3. **信号槽机制的优势**

- **解耦**：网络请求代码和 UI 更新代码完全分离
- **非阻塞**：信号槽是异步的，不会阻塞调用线程
- **线程安全**：Qt 的信号槽机制自动处理跨线程调用，确保 UI 更新在主线程执行

### 4. **与线程处理的对比**

**当前方案（异步请求）：**
- ✅ 实现简单，代码量少
- ✅ 利用 Qt 内置机制，稳定性好
- ✅ 自动处理线程同步，无需手动管理
- ❌ 无法在请求过程中取消（可以扩展实现）

**使用 QThread 的替代方案：**
- ✅ 可以精确控制线程生命周期
- ✅ 可以实现请求取消功能
- ⚠️ 需要手动管理线程同步
- ⚠️ 代码复杂度更高

**选择原因：** 对于简单的 HTTP GET 请求，`QNetworkAccessManager` 的异步机制已经足够，无需引入额外的线程管理复杂度。

---

## 六、总结

本系统的网络模块设计充分体现了 Qt 异步编程的优势：

1. **使用标准 HTTP 协议**：简单可靠，易于调试和维护
2. **异步请求机制**：通过 `QNetworkAccessManager` 实现非阻塞网络通信，确保 UI 响应流畅
3. **完善的错误处理**：覆盖网络错误、解析错误、空数据等多种异常情况
4. **信号槽架构**：实现网络模块与 UI 层的解耦，提高代码可维护性
5. **缓存优化**：优先使用本地缓存，减少网络请求，提升用户体验

整个网络请求流程清晰、健壮，既保证了功能的正确性，又确保了良好的用户体验。

